---
Class: "[[Operating Systems]]"
Title: Logical And Physical Address
date: 29-10-2025
Time: 09:08
type:
  - class-notes
tags:
  - Address
Related:
---
# Memory Management Unit & Address Translation

## Topic

Memory Management and Address Translation in Operating Systems

## Keywords

- Logical Address (Virtual Address)
- Physical Address
- Memory Management Unit (MMU)
- Address Translation
- Base and Limit Registers
- Page Tables
- Segmentation

## Notes

### Address Types

$$ Logical\space Address \implies Virtual\space Address $$

**Logical Address** is generated by CPU during program execution

- Also called **Virtual Address**
- Reference to memory location independent of physical memory
- Each process has its own logical address space (typically starts at 0)
- Programs work with logical addresses without knowing actual physical locations

$$ Physical\space Address \implies Actual\space Memory $$

**Physical Address** refers to actual location in RAM

- Real hardware memory address
- Managed by the operating system
- Multiple processes can have same logical address mapped to different physical addresses

### Address Translation Process

The translation from logical to physical addresses utilizes a **Memory Management Unit (MMU)**

## Memory Management Unit (MMU)

```mermaid
flowchart LR
    CPU["CPU<br/>(Generates Logical Address)"] --> MMU["Memory Management Unit<br/>(MMU)<br/>Translates Address"]
    MMU --> PM["Physical Memory<br/>(RAM)"]
    MMU -.->|"Uses"| PT["Page Table/<br/>Segment Table"]
```

### MMU Functions

1. **Address Translation**: Converts logical addresses to physical addresses
2. **Memory Protection**: Ensures processes cannot access unauthorized memory
3. **Memory Mapping**: Maps virtual address space to physical memory
4. **Cache Management**: Works with TLB (Translation Lookaside Buffer) for fast lookups

### Address Binding
- Compile Time address binding
- Load time address binding
- Dynamic Time address bindings
- Helps in code relocation
### MMU Components

#### Base and Limit Registers (Simple Scheme)

- **Base Register**: Contains starting physical address
- **Limit Register**: Defines size of logical address space
- Physical Address = Base + Logical Address
- If Logical Address ≥ Limit → Error (trap to OS)

#### Page Table (Paging Scheme)

- Divides memory into fixed-size blocks called **pages** (logical) and **frames** (physical)
- Page table stores mapping of page number to frame number
- Logical Address = Page Number + Page Offset
- Physical Address = Frame Number + Page Offset

#### Segment Table (Segmentation)

- Divides program into logical segments (code, data, stack)
- Each segment has base address and limit
- Provides better logical organization than paging

### Translation Lookaside Buffer (TLB)

```mermaid
flowchart TD
    LA["Logical Address"] --> TLB["TLB<br/>(Cache)"]
    TLB -->|Hit| PA1["Physical Address"]
    TLB -->|Miss| PT["Page Table<br/>(Main Memory)"]
    PT --> PA2["Physical Address"]
    PT -.->|"Update"| TLB
```

- High-speed cache for page table entries
- Stores recent address translations
- Significantly reduces memory access time
- Typical hit ratio: 95-99%

### Address Translation Example

**Paging Example:**

- Logical Address: 32 bits
- Page Size: 4 KB (2¹² bytes)
- Page Number: Upper 20 bits
- Offset: Lower 12 bits

If Logical Address = `0x00003ABC`:

- Page Number = `0x00003` (decimal 3)
- Offset = `0xABC` (decimal 2748)
- Look up Page 3 in page table → Frame Number (e.g., Frame 7)
- Physical Address = Frame 7 + Offset = `0x00007ABC`

### Memory Protection Mechanisms

1. **Protection Bits**: Read/Write/Execute permissions in page table
2. **Valid/Invalid Bit**: Indicates if page is in process's address space
3. **Privilege Levels**: User mode vs. Kernel mode access

### Advantages of Virtual Memory (via MMU)

- **Isolation**: Each process has separate address space
- **Protection**: Prevents unauthorized access between processes
- **Flexibility**: Programs larger than physical memory (via paging to disk)
- **Simplified Loading**: Programs can be loaded anywhere in physical memory
- **Sharing**: Multiple processes can share same physical pages (e.g., libraries)

### Common MMU Schemes Comparison

|Scheme|Unit Size|Advantages|Disadvantages|
|---|---|---|---|
|**Contiguous Allocation**|Entire process|Simple, fast|External fragmentation, no protection|
|**Paging**|Fixed (4KB-4MB)|No external fragmentation|Internal fragmentation, overhead|
|**Segmentation**|Variable|Logical organization|External fragmentation|
|**Segmented Paging**|Combined|Best of both|Complex, higher overhead|

---

## Work

- [x] Complete basic MMU concepts
- [x] Add address translation diagrams
- [x] Include TLB explanation
- [x] Add paging example with calculations
- [ ] Review different MMU implementations (x86, ARM, etc.)
- [ ] Study demand paging and page replacement algorithms
- [ ] Explore multi-level page tables
- [ ] Research modern MMU features (huge pages, PAE, SMEP)